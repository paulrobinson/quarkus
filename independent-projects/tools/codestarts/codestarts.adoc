= Quarkus - Codestarts

This guide explains how to create and configure a Quarkus Codestart for an extension.

== Description

"Codestarts" is the name we gave to our Quarkus quickstart code generation system. Codestarts are meant to provide a personalized Quarkus getting started experience and really show the Quarkus breadth.
Quarkus extension are able to provide one or more well defined codestarts which will contain all the necessary resources to bring user who pick that extension, everything they needs to get started with it.

== How it works

There are two kinds of codestarts contributing to generating a project,
the kind where we want to have only one for a project (called Base) and the rest (called Extra).

Base:
* project: The project skeleton (ex: a Quarkus project)
* buildtool: The build tool (ex: Maven, Gradle, Gradle with Kotlin DSL)
* language: The coding language (ex: Java, Kotlin, Scala)
* config: The config type (ex: yaml, properties)

Extra:
* tooling: Anything that can be added to improve the project (ex: dockerfiles)
* example: Any Quarkus extension can provide example code. The user can decide to activate it or not.

Each codestart consists of:

. a specific directory
. a codestart.yml file
. optionally some templates which follow a structure and naming conventions

*NOTE* The codestart.yml file and the directory structure follow the same principle, it can optionally contain a base and/or some language overrides.

=== Project generation

When generating a Quarkus project:

. codestarts to use are resolved depending on the input
. codestarts shared data is processed to make it available for all codestarts
. The relevant files are processed:
** Only the files that are related to the selected language are processed
** The files are processed differently based on a naming convention.
** The data is used to render Qute templates
** We always process in this order: language, project, buildtool, config, custom, other.

The data used to generate a specific codestart is a merge of:

. The data of the codestart to generate
. All codestarts "shared" data
. The user input
. Some specific post processing (ex: adding dependencies)

*NOTE* The data (shared or not) can also be specific to a language.

=== Directory structure

*NOTE* `codestart.yml` is the only required file.

* codestart.yml must be at the root of the codestart
* `./base` contains all the files that will be processed
* `./[languageName]` contains all the files that will be processed if the specified language has been selected (overriding base)

=== codestart.yml

codestart.yml:
[source,yaml]
----
name: the unique name - REQUIRED
ref: the reference name (not unique) to use for extension matching (else the name is used)
type: the type [example (default), project, buildtool, language, config] or any custom type
fallback: flag to indicate that it should be selected as fallback when no codestart has been selected with type - Only for base types
preselected: flag to indicate that it should be pre-selected - Only for extra types.
spec:
  [base or language name]: the specification (base, java, ...)
    data: a map of data to use only for this codestart
    shared-data: a map of data to use accross all codestarts
    dependencies: a list of dependencies to add when this is selected
    test-dependencies: a list of test dependencies to add when this is selected
----

=== Files naming convention

* containing `.qute` will be processed with Qute
* containing `.include-qute` is used as a Qute template for inclusion.

  Example: When using `{#include [name]}` in a template, it will look for `[name].include-qute` in the language dir, then in the base dir.

* containing `.append` will be appended together
* containing `.smart-config.yml` will be merged together and automatically converted to the selected config type (yml or properties)
* other files are just copied

*NOTE* there is also something specific for `pom.xml` but this should not be available out of internal codestarts.

=== Writing example code for an extension

Let's imagine we are writing the example codestart for my "foo" extension. As we discussed before, the base of the project is already provided so we can focus on the example code.

1. Create your codestart.yml:

codestart.yml:
[source,yaml]
----
---
name: foo-example
ref: foo
type: example
spec:
  base:
    data:
      # Some data for my templates which gives could be overridden by the user input
      some:
        data:
          here: bar
          there: foo
    dependencies:
      # the dependencies needed for my codestart (note that the extension dependency is auto-added if missing)
      - io.quarkus:quarkus-foo
      - io.quarkus:quarkus-resteasy
      # ... you can also provide a version (when it's not part of the platform bom)
      - group:artifact:version
    test-dependencies:
      # test dependencies
      - io.rest-assured:rest-assured
----

*NOTE* You don't need to add pom.xml or build.gradle, it is going to be auto generated. It will include the dependencies provided in the codestart.yml

2. Add you example code in java, kotlin and scala

* java/src/main/java/org/acme/foo/Foo.java:
[source,java]
----
package org.acme.foo

import javax.ws.rs.GET
import javax.ws.rs.Path
import javax.ws.rs.Produces
import javax.ws.rs.core.MediaType

@Path("foo")
class ExampleResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    fun hello() = "Hello foo"
}
----

* kotlin/src/main/kotlin/org/acme/foo/Foo.kt
* scala/src/main/scala/org/acme/foo/Foo.kt

*NOTE* Most of the time you won't need it for code, but you can use a `base` directory to add files to process for all languages.
*NOTE* If a language is not implemented, it will ignore this codestart for that language.

2. Add some configuration (if needed)

The config ".smart-config.yml" file is going to be merged with the other codestarts config and automatically converted to the selected config type (yaml or properties).

Note: if it's specific to a language, you can put the config in each languages folders

* base/src/main/resources/application.smart-config.yml (using quarkus yaml config convention):
[source,yaml]
----
quarkus:
  http:
    port: 8081
----

3. Create a readme section (if needed)

This will be appended to all different selected examples

* base/readme.append.md
[source,markdown]
----
# FOO Example

The Foo Example shows...
----

=== Tips for writing extension example code

- you don't need to care about buildtool, dockerfiles, ...
- use the package `org.acme.[unique-name]` for your sources.
- examples in different codestarts must be independent, only the config and the build file are merged.
- write the config in `src/main/resources/application.smart-config.yml`.
It is going to be merged with the other codestarts config and automatically converted to the selected config type (yaml or properties).
- you can add languages independently


== Problems to solve

- How to test that (in combinations)?
- Dependencies conflicts?
- Config conflicts?
- Versioning?